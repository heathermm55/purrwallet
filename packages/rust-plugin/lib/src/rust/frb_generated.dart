// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/cashu.dart';
import 'api/nostr.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiNostrInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.7.0';

  @override
  int get rustContentHash => -1700835654;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_nostr_rust',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<String> crateApiCashuAddMint({required String mintUrl});

  Future<String> crateApiCashuCheckAllMeltQuotes();

  Future<Map<String, String>> crateApiCashuCheckAllMintQuotes();

  Future<String> crateApiCashuCheckMeltQuoteStatus({required String mintUrl});

  Future<String> crateApiCashuCheckMintQuoteStatus({required String mintUrl});

  Future<Map<String, String>> crateApiCashuCreateMintQuote({
    required String mintUrl,
    required BigInt amount,
    String? description,
  });

  NostrKeys crateApiNostrGenerateKeys();

  NostrKeysWithBech32 crateApiNostrGenerateKeysWithBech32();

  Future<String> crateApiCashuGenerateMnemonicPhrase({required int wordCount});

  Future<Map<String, BigInt>> crateApiCashuGetAllBalances();

  Future<List<TransactionInfo>> crateApiCashuGetAllTransactions();

  Future<MintInfo> crateApiCashuGetMintInfo({required String mintUrl});

  String crateApiNostrGetPublicKeyFromPrivate({required String privateKey});

  Future<TorPolicy> crateApiCashuGetTorConfig();

  Future<WalletInfo> crateApiCashuGetWalletInfo({required String mintUrl});

  Future<List<CashuProof>> crateApiCashuGetWalletProofs({
    required String mintUrl,
  });

  String crateApiNostrGreet({required String name});

  Future<void> crateApiNostrInitApp();

  Future<String> crateApiCashuInitMultiMintWallet({
    required String databaseDir,
    required String seedHex,
  });

  Future<String> crateApiCashuInitMultiMintWalletWithTor({
    required String databaseDir,
    required String seedHex,
    TorConfig? torConfig,
  });

  Future<bool> crateApiCashuIsTorEnabled();

  Future<List<String>> crateApiCashuListMints();

  Future<String> crateApiCashuMnemonicToSeedHex({
    required String mnemonicPhrase,
  });

  String crateApiNostrNip04Decrypt({
    required String ciphertext,
    required String publicKey,
    required String privateKey,
  });

  String crateApiNostrNip04Encrypt({
    required String plaintext,
    required String publicKey,
    required String privateKey,
  });

  String crateApiNostrNip44Decrypt({
    required String ciphertext,
    required String publicKey,
    required String privateKey,
  });

  String crateApiNostrNip44Encrypt({
    required String plaintext,
    required String publicKey,
    required String privateKey,
  });

  String crateApiNostrNpubToPublicKey({required String npub});

  String crateApiNostrNsecToSecretKey({required String nsec});

  Future<Map<String, String>> crateApiCashuParseCashuToken({
    required String token,
  });

  Future<String> crateApiCashuPayInvoiceForWallet({
    required String mintUrl,
    required String bolt11Invoice,
    BigInt? maxFeeSats,
  });

  String crateApiNostrPublicKeyToNpub({required String publicKey});

  Future<BigInt> crateApiCashuReceiveTokens({required String token});

  Future<String> crateApiCashuReinitializeWithTorConfig({
    required String databaseDir,
    required String seedHex,
  });

  Future<String> crateApiCashuRemoveMint({required String mintUrl});

  String crateApiNostrSecretKeyToNsec({required String secretKey});

  Future<String> crateApiCashuSeedHexToMnemonic({required String seedHex});

  Future<String> crateApiCashuSendTokens({
    required String mintUrl,
    required BigInt amount,
    String? memo,
  });

  Future<void> crateApiCashuSetTorConfig({required TorPolicy policy});

  String crateApiNostrSignEvent({
    required String eventJson,
    required String privateKey,
  });

  Future<bool> crateApiCashuValidateMnemonicPhrase({
    required String mnemonicPhrase,
  });

  bool crateApiNostrVerifyEvent({required NostrEvent event});

  Future<bool> crateApiCashuVerifyTokenDleq({
    required String mintUrl,
    required String token,
  });

  Future<bool> crateApiCashuVerifyTokenP2Pk({
    required String mintUrl,
    required String token,
    required String conditions,
  });

  Future<bool> crateApiCashuWalletExists({
    required String mintUrl,
    required String databaseDir,
  });

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TorConfig;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TorConfig;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TorConfigPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> crateApiCashuAddMint({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuAddMintConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuAddMintConstMeta =>
      const TaskConstMeta(debugName: "add_mint", argNames: ["mintUrl"]);

  @override
  Future<String> crateApiCashuCheckAllMeltQuotes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuCheckAllMeltQuotesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuCheckAllMeltQuotesConstMeta =>
      const TaskConstMeta(debugName: "check_all_melt_quotes", argNames: []);

  @override
  Future<Map<String, String>> crateApiCashuCheckAllMintQuotes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_Map_String_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuCheckAllMintQuotesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuCheckAllMintQuotesConstMeta =>
      const TaskConstMeta(debugName: "check_all_mint_quotes", argNames: []);

  @override
  Future<String> crateApiCashuCheckMeltQuoteStatus({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuCheckMeltQuoteStatusConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuCheckMeltQuoteStatusConstMeta =>
      const TaskConstMeta(
        debugName: "check_melt_quote_status",
        argNames: ["mintUrl"],
      );

  @override
  Future<String> crateApiCashuCheckMintQuoteStatus({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuCheckMintQuoteStatusConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuCheckMintQuoteStatusConstMeta =>
      const TaskConstMeta(
        debugName: "check_mint_quote_status",
        argNames: ["mintUrl"],
      );

  @override
  Future<Map<String, String>> crateApiCashuCreateMintQuote({
    required String mintUrl,
    required BigInt amount,
    String? description,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_u_64(amount, serializer);
          sse_encode_opt_String(description, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_Map_String_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuCreateMintQuoteConstMeta,
        argValues: [mintUrl, amount, description],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuCreateMintQuoteConstMeta =>
      const TaskConstMeta(
        debugName: "create_mint_quote",
        argNames: ["mintUrl", "amount", "description"],
      );

  @override
  NostrKeys crateApiNostrGenerateKeys() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_nostr_keys,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrGenerateKeysConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrGenerateKeysConstMeta =>
      const TaskConstMeta(debugName: "generate_keys", argNames: []);

  @override
  NostrKeysWithBech32 crateApiNostrGenerateKeysWithBech32() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_nostr_keys_with_bech_32,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrGenerateKeysWithBech32ConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrGenerateKeysWithBech32ConstMeta =>
      const TaskConstMeta(debugName: "generate_keys_with_bech32", argNames: []);

  @override
  Future<String> crateApiCashuGenerateMnemonicPhrase({required int wordCount}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(wordCount, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGenerateMnemonicPhraseConstMeta,
        argValues: [wordCount],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGenerateMnemonicPhraseConstMeta =>
      const TaskConstMeta(
        debugName: "generate_mnemonic_phrase",
        argNames: ["wordCount"],
      );

  @override
  Future<Map<String, BigInt>> crateApiCashuGetAllBalances() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_Map_String_u_64,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetAllBalancesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetAllBalancesConstMeta =>
      const TaskConstMeta(debugName: "get_all_balances", argNames: []);

  @override
  Future<List<TransactionInfo>> crateApiCashuGetAllTransactions() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_transaction_info,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetAllTransactionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetAllTransactionsConstMeta =>
      const TaskConstMeta(debugName: "get_all_transactions", argNames: []);

  @override
  Future<MintInfo> crateApiCashuGetMintInfo({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_mint_info,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetMintInfoConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetMintInfoConstMeta =>
      const TaskConstMeta(debugName: "get_mint_info", argNames: ["mintUrl"]);

  @override
  String crateApiNostrGetPublicKeyFromPrivate({required String privateKey}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrGetPublicKeyFromPrivateConstMeta,
        argValues: [privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrGetPublicKeyFromPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "get_public_key_from_private",
        argNames: ["privateKey"],
      );

  @override
  Future<TorPolicy> crateApiCashuGetTorConfig() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_tor_policy,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetTorConfigConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetTorConfigConstMeta =>
      const TaskConstMeta(debugName: "get_tor_config", argNames: []);

  @override
  Future<WalletInfo> crateApiCashuGetWalletInfo({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_info,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetWalletInfoConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetWalletInfoConstMeta =>
      const TaskConstMeta(debugName: "get_wallet_info", argNames: ["mintUrl"]);

  @override
  Future<List<CashuProof>> crateApiCashuGetWalletProofs({
    required String mintUrl,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_cashu_proof,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuGetWalletProofsConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuGetWalletProofsConstMeta =>
      const TaskConstMeta(
        debugName: "get_wallet_proofs",
        argNames: ["mintUrl"],
      );

  @override
  String crateApiNostrGreet({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiNostrGreetConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrGreetConstMeta =>
      const TaskConstMeta(debugName: "greet", argNames: ["name"]);

  @override
  Future<void> crateApiNostrInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiNostrInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  Future<String> crateApiCashuInitMultiMintWallet({
    required String databaseDir,
    required String seedHex,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(databaseDir, serializer);
          sse_encode_String(seedHex, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuInitMultiMintWalletConstMeta,
        argValues: [databaseDir, seedHex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuInitMultiMintWalletConstMeta =>
      const TaskConstMeta(
        debugName: "init_multi_mint_wallet",
        argNames: ["databaseDir", "seedHex"],
      );

  @override
  Future<String> crateApiCashuInitMultiMintWalletWithTor({
    required String databaseDir,
    required String seedHex,
    TorConfig? torConfig,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(databaseDir, serializer);
          sse_encode_String(seedHex, serializer);
          sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
            torConfig,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuInitMultiMintWalletWithTorConstMeta,
        argValues: [databaseDir, seedHex, torConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuInitMultiMintWalletWithTorConstMeta =>
      const TaskConstMeta(
        debugName: "init_multi_mint_wallet_with_tor",
        argNames: ["databaseDir", "seedHex", "torConfig"],
      );

  @override
  Future<bool> crateApiCashuIsTorEnabled() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuIsTorEnabledConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuIsTorEnabledConstMeta =>
      const TaskConstMeta(debugName: "is_tor_enabled", argNames: []);

  @override
  Future<List<String>> crateApiCashuListMints() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuListMintsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuListMintsConstMeta =>
      const TaskConstMeta(debugName: "list_mints", argNames: []);

  @override
  Future<String> crateApiCashuMnemonicToSeedHex({
    required String mnemonicPhrase,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mnemonicPhrase, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuMnemonicToSeedHexConstMeta,
        argValues: [mnemonicPhrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuMnemonicToSeedHexConstMeta =>
      const TaskConstMeta(
        debugName: "mnemonic_to_seed_hex",
        argNames: ["mnemonicPhrase"],
      );

  @override
  String crateApiNostrNip04Decrypt({
    required String ciphertext,
    required String publicKey,
    required String privateKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(ciphertext, serializer);
          sse_encode_String(publicKey, serializer);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNip04DecryptConstMeta,
        argValues: [ciphertext, publicKey, privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNip04DecryptConstMeta => const TaskConstMeta(
    debugName: "nip04_decrypt",
    argNames: ["ciphertext", "publicKey", "privateKey"],
  );

  @override
  String crateApiNostrNip04Encrypt({
    required String plaintext,
    required String publicKey,
    required String privateKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(plaintext, serializer);
          sse_encode_String(publicKey, serializer);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNip04EncryptConstMeta,
        argValues: [plaintext, publicKey, privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNip04EncryptConstMeta => const TaskConstMeta(
    debugName: "nip04_encrypt",
    argNames: ["plaintext", "publicKey", "privateKey"],
  );

  @override
  String crateApiNostrNip44Decrypt({
    required String ciphertext,
    required String publicKey,
    required String privateKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(ciphertext, serializer);
          sse_encode_String(publicKey, serializer);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNip44DecryptConstMeta,
        argValues: [ciphertext, publicKey, privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNip44DecryptConstMeta => const TaskConstMeta(
    debugName: "nip44_decrypt",
    argNames: ["ciphertext", "publicKey", "privateKey"],
  );

  @override
  String crateApiNostrNip44Encrypt({
    required String plaintext,
    required String publicKey,
    required String privateKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(plaintext, serializer);
          sse_encode_String(publicKey, serializer);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNip44EncryptConstMeta,
        argValues: [plaintext, publicKey, privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNip44EncryptConstMeta => const TaskConstMeta(
    debugName: "nip44_encrypt",
    argNames: ["plaintext", "publicKey", "privateKey"],
  );

  @override
  String crateApiNostrNpubToPublicKey({required String npub}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(npub, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNpubToPublicKeyConstMeta,
        argValues: [npub],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNpubToPublicKeyConstMeta =>
      const TaskConstMeta(debugName: "npub_to_public_key", argNames: ["npub"]);

  @override
  String crateApiNostrNsecToSecretKey({required String nsec}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(nsec, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrNsecToSecretKeyConstMeta,
        argValues: [nsec],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrNsecToSecretKeyConstMeta =>
      const TaskConstMeta(debugName: "nsec_to_secret_key", argNames: ["nsec"]);

  @override
  Future<Map<String, String>> crateApiCashuParseCashuToken({
    required String token,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(token, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_Map_String_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuParseCashuTokenConstMeta,
        argValues: [token],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuParseCashuTokenConstMeta =>
      const TaskConstMeta(debugName: "parse_cashu_token", argNames: ["token"]);

  @override
  Future<String> crateApiCashuPayInvoiceForWallet({
    required String mintUrl,
    required String bolt11Invoice,
    BigInt? maxFeeSats,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_String(bolt11Invoice, serializer);
          sse_encode_opt_box_autoadd_u_64(maxFeeSats, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuPayInvoiceForWalletConstMeta,
        argValues: [mintUrl, bolt11Invoice, maxFeeSats],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuPayInvoiceForWalletConstMeta =>
      const TaskConstMeta(
        debugName: "pay_invoice_for_wallet",
        argNames: ["mintUrl", "bolt11Invoice", "maxFeeSats"],
      );

  @override
  String crateApiNostrPublicKeyToNpub({required String publicKey}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(publicKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrPublicKeyToNpubConstMeta,
        argValues: [publicKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrPublicKeyToNpubConstMeta =>
      const TaskConstMeta(
        debugName: "public_key_to_npub",
        argNames: ["publicKey"],
      );

  @override
  Future<BigInt> crateApiCashuReceiveTokens({required String token}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(token, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuReceiveTokensConstMeta,
        argValues: [token],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuReceiveTokensConstMeta =>
      const TaskConstMeta(debugName: "receive_tokens", argNames: ["token"]);

  @override
  Future<String> crateApiCashuReinitializeWithTorConfig({
    required String databaseDir,
    required String seedHex,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(databaseDir, serializer);
          sse_encode_String(seedHex, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuReinitializeWithTorConfigConstMeta,
        argValues: [databaseDir, seedHex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuReinitializeWithTorConfigConstMeta =>
      const TaskConstMeta(
        debugName: "reinitialize_with_tor_config",
        argNames: ["databaseDir", "seedHex"],
      );

  @override
  Future<String> crateApiCashuRemoveMint({required String mintUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuRemoveMintConstMeta,
        argValues: [mintUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuRemoveMintConstMeta =>
      const TaskConstMeta(debugName: "remove_mint", argNames: ["mintUrl"]);

  @override
  String crateApiNostrSecretKeyToNsec({required String secretKey}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(secretKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrSecretKeyToNsecConstMeta,
        argValues: [secretKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrSecretKeyToNsecConstMeta =>
      const TaskConstMeta(
        debugName: "secret_key_to_nsec",
        argNames: ["secretKey"],
      );

  @override
  Future<String> crateApiCashuSeedHexToMnemonic({required String seedHex}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(seedHex, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuSeedHexToMnemonicConstMeta,
        argValues: [seedHex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuSeedHexToMnemonicConstMeta =>
      const TaskConstMeta(
        debugName: "seed_hex_to_mnemonic",
        argNames: ["seedHex"],
      );

  @override
  Future<String> crateApiCashuSendTokens({
    required String mintUrl,
    required BigInt amount,
    String? memo,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_u_64(amount, serializer);
          sse_encode_opt_String(memo, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuSendTokensConstMeta,
        argValues: [mintUrl, amount, memo],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuSendTokensConstMeta => const TaskConstMeta(
    debugName: "send_tokens",
    argNames: ["mintUrl", "amount", "memo"],
  );

  @override
  Future<void> crateApiCashuSetTorConfig({required TorPolicy policy}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_tor_policy(policy, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuSetTorConfigConstMeta,
        argValues: [policy],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuSetTorConfigConstMeta =>
      const TaskConstMeta(debugName: "set_tor_config", argNames: ["policy"]);

  @override
  String crateApiNostrSignEvent({
    required String eventJson,
    required String privateKey,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(eventJson, serializer);
          sse_encode_String(privateKey, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrSignEventConstMeta,
        argValues: [eventJson, privateKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrSignEventConstMeta => const TaskConstMeta(
    debugName: "sign_event",
    argNames: ["eventJson", "privateKey"],
  );

  @override
  Future<bool> crateApiCashuValidateMnemonicPhrase({
    required String mnemonicPhrase,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mnemonicPhrase, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuValidateMnemonicPhraseConstMeta,
        argValues: [mnemonicPhrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuValidateMnemonicPhraseConstMeta =>
      const TaskConstMeta(
        debugName: "validate_mnemonic_phrase",
        argNames: ["mnemonicPhrase"],
      );

  @override
  bool crateApiNostrVerifyEvent({required NostrEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_nostr_event(event, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiNostrVerifyEventConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiNostrVerifyEventConstMeta =>
      const TaskConstMeta(debugName: "verify_event", argNames: ["event"]);

  @override
  Future<bool> crateApiCashuVerifyTokenDleq({
    required String mintUrl,
    required String token,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_String(token, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuVerifyTokenDleqConstMeta,
        argValues: [mintUrl, token],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuVerifyTokenDleqConstMeta =>
      const TaskConstMeta(
        debugName: "verify_token_dleq",
        argNames: ["mintUrl", "token"],
      );

  @override
  Future<bool> crateApiCashuVerifyTokenP2Pk({
    required String mintUrl,
    required String token,
    required String conditions,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_String(token, serializer);
          sse_encode_String(conditions, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiCashuVerifyTokenP2PkConstMeta,
        argValues: [mintUrl, token, conditions],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuVerifyTokenP2PkConstMeta =>
      const TaskConstMeta(
        debugName: "verify_token_p2pk",
        argNames: ["mintUrl", "token", "conditions"],
      );

  @override
  Future<bool> crateApiCashuWalletExists({
    required String mintUrl,
    required String databaseDir,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(mintUrl, serializer);
          sse_encode_String(databaseDir, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCashuWalletExistsConstMeta,
        argValues: [mintUrl, databaseDir],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCashuWalletExistsConstMeta => const TaskConstMeta(
    debugName: "wallet_exists",
    argNames: ["mintUrl", "databaseDir"],
  );

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TorConfig =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TorConfig =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig;

  @protected
  TorConfig
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TorConfigImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_string(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Map<String, BigInt> dco_decode_Map_String_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_u_64(raw).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  TorConfig
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TorConfigImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  TorConfig
  dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
      raw,
    );
  }

  @protected
  NostrEvent dco_decode_box_autoadd_nostr_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_nostr_event(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  CashuProof dco_decode_cashu_proof(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return CashuProof(
      id: dco_decode_String(arr[0]),
      amount: dco_decode_u_64(arr[1]),
      secret: dco_decode_String(arr[2]),
      c: dco_decode_String(arr[3]),
    );
  }

  @protected
  ContactInfo dco_decode_contact_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ContactInfo(
      method: dco_decode_String(arr[0]),
      info: dco_decode_String(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<CashuProof> dco_decode_list_cashu_proof(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_cashu_proof).toList();
  }

  @protected
  List<ContactInfo> dco_decode_list_contact_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_contact_info).toList();
  }

  @protected
  List<List<String>> dco_decode_list_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_String).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, BigInt)> dco_decode_list_record_string_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_u_64).toList();
  }

  @protected
  List<TransactionInfo> dco_decode_list_transaction_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction_info).toList();
  }

  @protected
  MintInfo dco_decode_mint_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return MintInfo(
      name: dco_decode_opt_String(arr[0]),
      version: dco_decode_opt_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
      descriptionLong: dco_decode_opt_String(arr[3]),
      contact: dco_decode_opt_list_contact_info(arr[4]),
      motd: dco_decode_opt_String(arr[5]),
      iconUrl: dco_decode_opt_String(arr[6]),
      urls: dco_decode_opt_list_String(arr[7]),
      nuts: dco_decode_opt_list_String(arr[8]),
      publicKey: dco_decode_opt_String(arr[9]),
      additionalInfo: dco_decode_opt_String(arr[10]),
    );
  }

  @protected
  NostrEvent dco_decode_nostr_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return NostrEvent(
      id: dco_decode_String(arr[0]),
      pubkey: dco_decode_String(arr[1]),
      createdAt: dco_decode_u_64(arr[2]),
      kind: dco_decode_u_64(arr[3]),
      tags: dco_decode_list_list_String(arr[4]),
      content: dco_decode_String(arr[5]),
      sig: dco_decode_String(arr[6]),
    );
  }

  @protected
  NostrKeys dco_decode_nostr_keys(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NostrKeys(
      publicKey: dco_decode_String(arr[0]),
      privateKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  NostrKeysWithBech32 dco_decode_nostr_keys_with_bech_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return NostrKeysWithBech32(
      privateKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
      nsec: dco_decode_String(arr[2]),
      npub: dco_decode_String(arr[3]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  TorConfig?
  dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
          raw,
        );
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<ContactInfo>? dco_decode_opt_list_contact_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_contact_info(raw);
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  (String, BigInt) dco_decode_record_string_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_u_64(arr[1]));
  }

  @protected
  TorPolicy dco_decode_tor_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TorPolicy.values[raw as int];
  }

  @protected
  TransactionInfo dco_decode_transaction_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return TransactionInfo(
      id: dco_decode_String(arr[0]),
      direction: dco_decode_String(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      memo: dco_decode_opt_String(arr[3]),
      timestamp: dco_decode_u_64(arr[4]),
      transactionType: dco_decode_opt_String(arr[5]),
      lightningInvoice: dco_decode_opt_String(arr[6]),
      ecashToken: dco_decode_opt_String(arr[7]),
      metadata: dco_decode_Map_String_String(arr[8]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WalletInfo dco_decode_wallet_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return WalletInfo(
      mintUrl: dco_decode_String(arr[0]),
      unit: dco_decode_String(arr[1]),
      balance: dco_decode_u_64(arr[2]),
      activeKeysetId: dco_decode_String(arr[3]),
    );
  }

  @protected
  TorConfig
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TorConfigImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Map<String, String> sse_decode_Map_String_String(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, BigInt> sse_decode_Map_String_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_u_64(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  TorConfig
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TorConfigImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  TorConfig
  sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
      deserializer,
    ));
  }

  @protected
  NostrEvent sse_decode_box_autoadd_nostr_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_nostr_event(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  CashuProof sse_decode_cashu_proof(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_secret = sse_decode_String(deserializer);
    var var_c = sse_decode_String(deserializer);
    return CashuProof(
      id: var_id,
      amount: var_amount,
      secret: var_secret,
      c: var_c,
    );
  }

  @protected
  ContactInfo sse_decode_contact_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_method = sse_decode_String(deserializer);
    var var_info = sse_decode_String(deserializer);
    return ContactInfo(method: var_method, info: var_info);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<CashuProof> sse_decode_list_cashu_proof(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CashuProof>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_cashu_proof(deserializer));
    }
    return ans_;
  }

  @protected
  List<ContactInfo> sse_decode_list_contact_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ContactInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_contact_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<List<String>> sse_decode_list_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <List<String>>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_String(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, BigInt)> sse_decode_list_record_string_u_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_u_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionInfo> sse_decode_list_transaction_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_info(deserializer));
    }
    return ans_;
  }

  @protected
  MintInfo sse_decode_mint_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_opt_String(deserializer);
    var var_version = sse_decode_opt_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionLong = sse_decode_opt_String(deserializer);
    var var_contact = sse_decode_opt_list_contact_info(deserializer);
    var var_motd = sse_decode_opt_String(deserializer);
    var var_iconUrl = sse_decode_opt_String(deserializer);
    var var_urls = sse_decode_opt_list_String(deserializer);
    var var_nuts = sse_decode_opt_list_String(deserializer);
    var var_publicKey = sse_decode_opt_String(deserializer);
    var var_additionalInfo = sse_decode_opt_String(deserializer);
    return MintInfo(
      name: var_name,
      version: var_version,
      description: var_description,
      descriptionLong: var_descriptionLong,
      contact: var_contact,
      motd: var_motd,
      iconUrl: var_iconUrl,
      urls: var_urls,
      nuts: var_nuts,
      publicKey: var_publicKey,
      additionalInfo: var_additionalInfo,
    );
  }

  @protected
  NostrEvent sse_decode_nostr_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_createdAt = sse_decode_u_64(deserializer);
    var var_kind = sse_decode_u_64(deserializer);
    var var_tags = sse_decode_list_list_String(deserializer);
    var var_content = sse_decode_String(deserializer);
    var var_sig = sse_decode_String(deserializer);
    return NostrEvent(
      id: var_id,
      pubkey: var_pubkey,
      createdAt: var_createdAt,
      kind: var_kind,
      tags: var_tags,
      content: var_content,
      sig: var_sig,
    );
  }

  @protected
  NostrKeys sse_decode_nostr_keys(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_String(deserializer);
    var var_privateKey = sse_decode_String(deserializer);
    return NostrKeys(publicKey: var_publicKey, privateKey: var_privateKey);
  }

  @protected
  NostrKeysWithBech32 sse_decode_nostr_keys_with_bech_32(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_nsec = sse_decode_String(deserializer);
    var var_npub = sse_decode_String(deserializer);
    return NostrKeysWithBech32(
      privateKey: var_privateKey,
      publicKey: var_publicKey,
      nsec: var_nsec,
      npub: var_npub,
    );
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TorConfig?
  sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
        deserializer,
      ));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ContactInfo>? sse_decode_opt_list_contact_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_contact_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, BigInt) sse_decode_record_string_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  TorPolicy sse_decode_tor_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TorPolicy.values[inner];
  }

  @protected
  TransactionInfo sse_decode_transaction_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_direction = sse_decode_String(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_memo = sse_decode_opt_String(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_transactionType = sse_decode_opt_String(deserializer);
    var var_lightningInvoice = sse_decode_opt_String(deserializer);
    var var_ecashToken = sse_decode_opt_String(deserializer);
    var var_metadata = sse_decode_Map_String_String(deserializer);
    return TransactionInfo(
      id: var_id,
      direction: var_direction,
      amount: var_amount,
      memo: var_memo,
      timestamp: var_timestamp,
      transactionType: var_transactionType,
      lightningInvoice: var_lightningInvoice,
      ecashToken: var_ecashToken,
      metadata: var_metadata,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WalletInfo sse_decode_wallet_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mintUrl = sse_decode_String(deserializer);
    var var_unit = sse_decode_String(deserializer);
    var var_balance = sse_decode_u_64(deserializer);
    var var_activeKeysetId = sse_decode_String(deserializer);
    return WalletInfo(
      mintUrl: var_mintUrl,
      unit: var_unit,
      balance: var_balance,
      activeKeysetId: var_activeKeysetId,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    TorConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TorConfigImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void sse_encode_Map_String_String(
    Map<String, String> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void sse_encode_Map_String_u_64(
    Map<String, BigInt> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_u_64(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    TorConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TorConfigImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
  sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    TorConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
      self,
      serializer,
    );
  }

  @protected
  void sse_encode_box_autoadd_nostr_event(
    NostrEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_nostr_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_cashu_proof(CashuProof self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_String(self.secret, serializer);
    sse_encode_String(self.c, serializer);
  }

  @protected
  void sse_encode_contact_info(ContactInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.method, serializer);
    sse_encode_String(self.info, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_cashu_proof(
    List<CashuProof> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_cashu_proof(item, serializer);
    }
  }

  @protected
  void sse_encode_list_contact_info(
    List<ContactInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_contact_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_String(
    List<List<String>> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_u_64(
    List<(String, BigInt)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_u_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_info(
    List<TransactionInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_info(item, serializer);
    }
  }

  @protected
  void sse_encode_mint_info(MintInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.name, serializer);
    sse_encode_opt_String(self.version, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionLong, serializer);
    sse_encode_opt_list_contact_info(self.contact, serializer);
    sse_encode_opt_String(self.motd, serializer);
    sse_encode_opt_String(self.iconUrl, serializer);
    sse_encode_opt_list_String(self.urls, serializer);
    sse_encode_opt_list_String(self.nuts, serializer);
    sse_encode_opt_String(self.publicKey, serializer);
    sse_encode_opt_String(self.additionalInfo, serializer);
  }

  @protected
  void sse_encode_nostr_event(NostrEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_u_64(self.createdAt, serializer);
    sse_encode_u_64(self.kind, serializer);
    sse_encode_list_list_String(self.tags, serializer);
    sse_encode_String(self.content, serializer);
    sse_encode_String(self.sig, serializer);
  }

  @protected
  void sse_encode_nostr_keys(NostrKeys self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.privateKey, serializer);
  }

  @protected
  void sse_encode_nostr_keys_with_bech_32(
    NostrKeysWithBech32 self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateKey, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.nsec, serializer);
    sse_encode_String(self.npub, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
  sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
    TorConfig? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTorConfig(
        self,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
    List<String>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_contact_info(
    List<ContactInfo>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_contact_info(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_u_64(
    (String, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
  }

  @protected
  void sse_encode_tor_policy(TorPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_transaction_info(
    TransactionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.direction, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_opt_String(self.memo, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_opt_String(self.transactionType, serializer);
    sse_encode_opt_String(self.lightningInvoice, serializer);
    sse_encode_opt_String(self.ecashToken, serializer);
    sse_encode_Map_String_String(self.metadata, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wallet_info(WalletInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.mintUrl, serializer);
    sse_encode_String(self.unit, serializer);
    sse_encode_u_64(self.balance, serializer);
    sse_encode_String(self.activeKeysetId, serializer);
  }
}

@sealed
class TorConfigImpl extends RustOpaque implements TorConfig {
  // Not to be used by end users
  TorConfigImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TorConfigImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TorConfig,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TorConfig,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TorConfigPtr,
  );
}
