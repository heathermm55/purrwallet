// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `extract_supported_nuts`, `get_database_path`, `load_wallets_from_database`, `parse_seed_from_hex`, `wallet_database_exists`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `try_from`

/// Initialize MultiMintWallet
Future<String> initMultiMintWallet({
  required String databaseDir,
  required String seedHex,
}) => RustLib.instance.api.crateApiCashuInitMultiMintWallet(
  databaseDir: databaseDir,
  seedHex: seedHex,
);

/// Add a mint to MultiMintWallet - defaults to sat unit
Future<String> addMint({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuAddMint(mintUrl: mintUrl);

/// Remove a mint from MultiMintWallet - defaults to sat unit
Future<String> removeMint({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuRemoveMint(mintUrl: mintUrl);

/// List all mints in MultiMintWallet
Future<List<String>> listMints() =>
    RustLib.instance.api.crateApiCashuListMints();

/// Check if wallet exists
Future<bool> walletExists({
  required String mintUrl,
  required String databaseDir,
}) => RustLib.instance.api.crateApiCashuWalletExists(
  mintUrl: mintUrl,
  databaseDir: databaseDir,
);

/// Get wallet information (may make network requests for keyset info) - defaults to sat unit
Future<WalletInfo> getWalletInfo({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuGetWalletInfo(mintUrl: mintUrl);

/// Get all transactions from all mints (fast, no network requests)
Future<List<TransactionInfo>> getAllTransactions() =>
    RustLib.instance.api.crateApiCashuGetAllTransactions();

/// Get all wallet balances from all mints (fast, no network requests)
Future<Map<String, BigInt>> getAllBalances() =>
    RustLib.instance.api.crateApiCashuGetAllBalances();

/// Get mint information from NUT-06 endpoint - defaults to sat unit
Future<MintInfo> getMintInfo({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuGetMintInfo(mintUrl: mintUrl);

/// Send tokens using CDK MultiMintWallet API directly - defaults to sat unit
Future<String> sendTokens({
  required String mintUrl,
  required BigInt amount,
  String? memo,
}) => RustLib.instance.api.crateApiCashuSendTokens(
  mintUrl: mintUrl,
  amount: amount,
  memo: memo,
);

/// Receive tokens using CDK MultiMintWallet API directly - auto-detects mint URL from token
Future<BigInt> receiveTokens({required String token}) =>
    RustLib.instance.api.crateApiCashuReceiveTokens(token: token);

/// Create mint quote using CDK MultiMintWallet API directly - defaults to sat unit
Future<Map<String, String>> createMintQuote({
  required String mintUrl,
  required BigInt amount,
  String? description,
}) => RustLib.instance.api.crateApiCashuCreateMintQuote(
  mintUrl: mintUrl,
  amount: amount,
  description: description,
);

/// Check all mint quotes and automatically mint if paid - defaults to sat unit
Future<String> checkMintQuoteStatus({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuCheckMintQuoteStatus(mintUrl: mintUrl);

/// Get wallet proofs - defaults to sat unit
Future<List<CashuProof>> getWalletProofs({required String mintUrl}) =>
    RustLib.instance.api.crateApiCashuGetWalletProofs(mintUrl: mintUrl);

/// Parse Cashu token string
Future<Map<String, String>> parseCashuToken({required String token}) =>
    RustLib.instance.api.crateApiCashuParseCashuToken(token: token);

/// Generate a new BIP39 mnemonic phrase (12 or 24 words)
Future<String> generateMnemonicPhrase({required int wordCount}) => RustLib
    .instance
    .api
    .crateApiCashuGenerateMnemonicPhrase(wordCount: wordCount);

/// Convert mnemonic phrase to seed hex (64 hex characters)
Future<String> mnemonicToSeedHex({required String mnemonicPhrase}) => RustLib
    .instance
    .api
    .crateApiCashuMnemonicToSeedHex(mnemonicPhrase: mnemonicPhrase);

/// Convert seed hex to mnemonic phrase (for verification/testing)
Future<String> seedHexToMnemonic({required String seedHex}) =>
    RustLib.instance.api.crateApiCashuSeedHexToMnemonic(seedHex: seedHex);

/// Pay lightning invoice using wallet tokens - defaults to sat unit
Future<String> payInvoiceForWallet({
  required String mintUrl,
  required String bolt11Invoice,
  BigInt? maxFeeSats,
}) => RustLib.instance.api.crateApiCashuPayInvoiceForWallet(
  mintUrl: mintUrl,
  bolt11Invoice: bolt11Invoice,
  maxFeeSats: maxFeeSats,
);

/// Verify token matches p2pk conditions - defaults to sat unit
Future<bool> verifyTokenP2Pk({
  required String mintUrl,
  required String token,
  required String conditions,
}) => RustLib.instance.api.crateApiCashuVerifyTokenP2Pk(
  mintUrl: mintUrl,
  token: token,
  conditions: conditions,
);

/// Verify all proofs in token have valid dleq proof - defaults to sat unit
Future<bool> verifyTokenDleq({
  required String mintUrl,
  required String token,
}) => RustLib.instance.api.crateApiCashuVerifyTokenDleq(
  mintUrl: mintUrl,
  token: token,
);

/// Validate a mnemonic phrase
Future<bool> validateMnemonicPhrase({required String mnemonicPhrase}) => RustLib
    .instance
    .api
    .crateApiCashuValidateMnemonicPhrase(mnemonicPhrase: mnemonicPhrase);

/// Cashu proof structure for FFI
class CashuProof {
  final String id;
  final BigInt amount;
  final String secret;
  final String c;

  const CashuProof({
    required this.id,
    required this.amount,
    required this.secret,
    required this.c,
  });

  @override
  int get hashCode =>
      id.hashCode ^ amount.hashCode ^ secret.hashCode ^ c.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CashuProof &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          amount == other.amount &&
          secret == other.secret &&
          c == other.c;
}

/// Contact information structure
class ContactInfo {
  final String method;
  final String info;

  const ContactInfo({required this.method, required this.info});

  @override
  int get hashCode => method.hashCode ^ info.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactInfo &&
          runtimeType == other.runtimeType &&
          method == other.method &&
          info == other.info;
}

/// Mint information structure for NUT-06
class MintInfo {
  final String? name;
  final String? version;
  final String? description;
  final String? descriptionLong;
  final List<ContactInfo>? contact;
  final String? motd;
  final String? iconUrl;
  final List<String>? urls;
  final List<String>? nuts;
  final String? publicKey;
  final String? additionalInfo;

  const MintInfo({
    this.name,
    this.version,
    this.description,
    this.descriptionLong,
    this.contact,
    this.motd,
    this.iconUrl,
    this.urls,
    this.nuts,
    this.publicKey,
    this.additionalInfo,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      version.hashCode ^
      description.hashCode ^
      descriptionLong.hashCode ^
      contact.hashCode ^
      motd.hashCode ^
      iconUrl.hashCode ^
      urls.hashCode ^
      nuts.hashCode ^
      publicKey.hashCode ^
      additionalInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MintInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          version == other.version &&
          description == other.description &&
          descriptionLong == other.descriptionLong &&
          contact == other.contact &&
          motd == other.motd &&
          iconUrl == other.iconUrl &&
          urls == other.urls &&
          nuts == other.nuts &&
          publicKey == other.publicKey &&
          additionalInfo == other.additionalInfo;
}

/// Transaction information structure
class TransactionInfo {
  final String id;
  final String direction;
  final BigInt amount;
  final String? memo;
  final BigInt timestamp;

  const TransactionInfo({
    required this.id,
    required this.direction,
    required this.amount,
    this.memo,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      direction.hashCode ^
      amount.hashCode ^
      memo.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          direction == other.direction &&
          amount == other.amount &&
          memo == other.memo &&
          timestamp == other.timestamp;
}

/// Wallet information structure
class WalletInfo {
  final String mintUrl;
  final String unit;
  final BigInt balance;
  final String activeKeysetId;

  const WalletInfo({
    required this.mintUrl,
    required this.unit,
    required this.balance,
    required this.activeKeysetId,
  });

  @override
  int get hashCode =>
      mintUrl.hashCode ^
      unit.hashCode ^
      balance.hashCode ^
      activeKeysetId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletInfo &&
          runtimeType == other.runtimeType &&
          mintUrl == other.mintUrl &&
          unit == other.unit &&
          balance == other.balance &&
          activeKeysetId == other.activeKeysetId;
}
