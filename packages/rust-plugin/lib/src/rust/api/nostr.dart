// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `fmt`

NostrKeys generateKeys() => RustLib.instance.api.crateApiNostrGenerateKeys();

String getPublicKeyFromPrivate({required String privateKey}) => RustLib
    .instance
    .api
    .crateApiNostrGetPublicKeyFromPrivate(privateKey: privateKey);

String nip04Encrypt({
  required String plaintext,
  required String publicKey,
  required String privateKey,
}) => RustLib.instance.api.crateApiNostrNip04Encrypt(
  plaintext: plaintext,
  publicKey: publicKey,
  privateKey: privateKey,
);

String nip04Decrypt({
  required String ciphertext,
  required String publicKey,
  required String privateKey,
}) => RustLib.instance.api.crateApiNostrNip04Decrypt(
  ciphertext: ciphertext,
  publicKey: publicKey,
  privateKey: privateKey,
);

String nip44Encrypt({
  required String plaintext,
  required String publicKey,
  required String privateKey,
}) => RustLib.instance.api.crateApiNostrNip44Encrypt(
  plaintext: plaintext,
  publicKey: publicKey,
  privateKey: privateKey,
);

String nip44Decrypt({
  required String ciphertext,
  required String publicKey,
  required String privateKey,
}) => RustLib.instance.api.crateApiNostrNip44Decrypt(
  ciphertext: ciphertext,
  publicKey: publicKey,
  privateKey: privateKey,
);

String signEvent({required String eventJson, required String privateKey}) =>
    RustLib.instance.api.crateApiNostrSignEvent(
      eventJson: eventJson,
      privateKey: privateKey,
    );

bool verifyEvent({required NostrEvent event}) =>
    RustLib.instance.api.crateApiNostrVerifyEvent(event: event);

String greet({required String name}) =>
    RustLib.instance.api.crateApiNostrGreet(name: name);

/// Convert secret key to nsec format
String secretKeyToNsec({required String secretKey}) =>
    RustLib.instance.api.crateApiNostrSecretKeyToNsec(secretKey: secretKey);

/// Convert public key to npub format
String publicKeyToNpub({required String publicKey}) =>
    RustLib.instance.api.crateApiNostrPublicKeyToNpub(publicKey: publicKey);

/// Convert nsec to secret key hex
String nsecToSecretKey({required String nsec}) =>
    RustLib.instance.api.crateApiNostrNsecToSecretKey(nsec: nsec);

/// Convert npub to public key hex
String npubToPublicKey({required String npub}) =>
    RustLib.instance.api.crateApiNostrNpubToPublicKey(npub: npub);

/// Generate keys and return both hex and bech32 formats
NostrKeysWithBech32 generateKeysWithBech32() =>
    RustLib.instance.api.crateApiNostrGenerateKeysWithBech32();

class NostrEvent {
  final String id;
  final String pubkey;
  final BigInt createdAt;
  final BigInt kind;
  final List<List<String>> tags;
  final String content;
  final String sig;

  const NostrEvent({
    required this.id,
    required this.pubkey,
    required this.createdAt,
    required this.kind,
    required this.tags,
    required this.content,
    required this.sig,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      pubkey.hashCode ^
      createdAt.hashCode ^
      kind.hashCode ^
      tags.hashCode ^
      content.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NostrEvent &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          kind == other.kind &&
          tags == other.tags &&
          content == other.content &&
          sig == other.sig;
}

class NostrKeys {
  final String publicKey;
  final String privateKey;

  const NostrKeys({required this.publicKey, required this.privateKey});

  @override
  int get hashCode => publicKey.hashCode ^ privateKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NostrKeys &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          privateKey == other.privateKey;
}

class NostrKeysWithBech32 {
  final String privateKey;
  final String publicKey;
  final String nsec;
  final String npub;

  const NostrKeysWithBech32({
    required this.privateKey,
    required this.publicKey,
    required this.nsec,
    required this.npub,
  });

  @override
  int get hashCode =>
      privateKey.hashCode ^ publicKey.hashCode ^ nsec.hashCode ^ npub.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NostrKeysWithBech32 &&
          runtimeType == other.runtimeType &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey &&
          nsec == other.nsec &&
          npub == other.npub;
}
